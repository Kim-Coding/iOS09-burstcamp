//
//  MockHTMLString.swift
//  burstcamp
//
//  Created by SEUNGMIN OH on 2022/11/24.
//

import UIKit

extension String {
    static var htmlReadability: String {
        #"<div id="readability-page-1" class="page"><div><p data-ke-size="size18"><span>안녕하세요 :) Zedd입니다.</span></p><pre id="code_1668928901870" data-ke-language="bash" data-ke-type="codeblock"><code>@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")<br>public struct NavigationView&lt;Content&gt; : View where Content : View { ... }</code></pre><p data-ke-size="size18"><span>WWDC22에서 NavigationView가 deprecated되고 NavigationStack/NavigationSplitView가 나왔는데...한번 바꿔보려고 합니다.</span></p><blockquote data-ke-style="style3">&nbsp;💡 <span>NavigationStack/NavigationSplitView가<b> iOS 16+ 부터 사용할 수 있기 때문에</b>, 앱의 Deployment Target이 16+ 이상인경우에만 진행하는게 좋습니다.&nbsp;</span></blockquote><p data-ke-size="size18"><span><br>이 글에서 NavigationSplitView는 따로 다루지 않습니다.</span></p><div data-v-702ae484="" data-v-b3ef72b8="" data-v-97436168="" data-v-1aa4701e=""><pre id="code_1668929752937" data-ke-language="bash" data-ke-type="codeblock"><code>RootView를 표시하고, Root View에 대한 추가(additional) View를 제공할 있는 View​</code></pre></div><p data-ke-size="size18"><span>앱이 굳이 Split 되어서 보여질 필요가 없다면, <b>즉 Single column navigation을 사용한다면 NavigationStack을 사용하는 것이 좋습니다.&nbsp;<br></b></span></p><p data-ke-size="size18"><span>기존 (deprecated된) NavigationView를 사용할때는</span></p><div data-v-702ae484="" data-v-b3ef72b8="" data-v-97436168="" data-v-1aa4701e=""><pre id="code_1668929428176" data-ke-language="swift" data-ke-type="codeblock"><code>NavigationView { <br> /* content */<br>}<br>.navigationViewStyle(.stack) ✅</code></pre></div><p data-ke-size="size18"><span>이런식으로 navigationViewStyle을 stack으로 주었을텐데,&nbsp;</span></p><p data-ke-size="size18"><span>NavigationStack을 사용한다면&nbsp;</span></p><pre id="code_1668929464881" data-ke-language="swift" data-ke-type="codeblock"><code>NavigationStack {<br> /* content */<br>}</code></pre><p data-ke-size="size18"><span>이렇게만 사용하면 됩니다.&nbsp;</span></p><p data-ke-size="size18"><b><span>Stack은 항상 제거되지 않은 가장 최근에 추가된 View를 표시하며, RootView는 제거할 수 없다!&nbsp;</span></b></p><h2 data-ke-size="size26"><b><span># NavigationLink와 .navigationDestination</span></b></h2><p data-ke-size="size18"><span>NavigationStack을 사용한다면, <b>NavigationLink와 .navigationDestination modifier는 그냥 세트</b>로 다닌다고 생각하면 됩니다.</span></p><p data-ke-size="size18"><span>✔️ <b>NavigationLink</b> - 탐색 Presentation을 제어하는 <span><b>View</b></span>.&nbsp;</span></p><p data-ke-size="size18"><span>✔️&nbsp;<b>navigationDestination(for:destination:)</b>&nbsp; - Destination View를 NaviationLink에서 제시된 Data 타입과 연결해주는 <span><b>Method</b></span></span></p><pre id="code_1668930105269" data-ke-language="swift" data-ke-type="codeblock"><code>var body: some View {<br>  NavigationStack {<br>   List {<br>    NavigationLink("Mint", value: Color.mint)<br>    NavigationLink("Pink", value: Color.pink)<br>    NavigationLink("Teal", value: Color.teal)<br>   }<br>   .navigationTitle("Colors")<br>  }<br>}</code></pre><p data-ke-size="size18"><span>이렇게만 해주면</span></p><figure data-ke-mobilestyle="widthOrigin" data-filename="스크린샷 2022-11-20 오후 4.42.56.png" data-origin-width="816" data-origin-height="494"><span data-url="https://blog.kakaocdn.net/dn/EfEis/btrRAiiyZPa/9bZ1iHzY8TQyMmO0nW10ik/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/EfEis/btrRAiiyZPa/9bZ1iHzY8TQyMmO0nW10ik/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEfEis%2FbtrRAiiyZPa%2F9bZ1iHzY8TQyMmO0nW10ik%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-filename="스크린샷 2022-11-20 오후 4.42.56.png" data-origin-width="816" data-origin-height="494"></span></figure><p data-ke-size="size18"><span>이렇게 Navigation을 위한 View들만 만들어지고, 클릭하면 아무런 이동도 안하는데요. (NaviationLink가 View니까)</span></p><p data-ke-size="size18"><span>우리가 원하는 것 -&gt; 눌렀을 때 내가 원하는 <b>1) View로</b>&nbsp; <b>2) Navigation되었으면 좋겠어.</b>&nbsp;</span></p><p data-ke-size="size18"><b><span>[준비물]</span></b></p><p data-ke-size="size18"><span>1. 눌렀을 때 이동할 View&nbsp;</span></p><pre id="code_1668930349475" data-ke-language="swift" data-ke-type="codeblock"><code>struct ColorDetail: View {<p>  var color: Color</p><p>  var body: some View {<br>  Text("\(self.color.description)")<br> }<br>}</p></code></pre><p data-ke-size="size18"><span>2. navigationDestination(for:destination:) 사용</span></p><pre id="code_1668930383866" data-ke-language="swift" data-ke-type="codeblock"><code>var body: some View {<br>   NavigationStack {<br>    List {<br>     NavigationLink("Mint", value: Color.mint)<br>     NavigationLink("Pink", value: Color.pink)<br>     NavigationLink("Teal", value: Color.teal)<br>    }<br>    .navigationDestination(for: Color.self) { color in ✅<br>     ColorDetail(color: color)<br>    }<br>    .navigationTitle("Colors")<br>   }<br> }</code></pre><p data-ke-size="size18"><span>⚠️ 주의할 점 ⚠️</span></p><pre id="code_1668930503979" data-ke-language="swift" data-ke-type="codeblock"><code>NavigationLink("Teal", value: Color.teal)</code></pre><p data-ke-size="size18"><span>NavigationLink에 제시된 Data타입 ➡️ Color</span></p><pre id="code_1668930532042" data-ke-language="swift" data-ke-type="codeblock"><code>.navigationDestination(for: Color.self)</code></pre><p data-ke-size="size18"><span>navigationDestination(for:destination:) <span>➡️</span> Color</span></p><p data-ke-size="size18"><span>이 Data 타입이 같지 않으면 Navigation을 하지 않으니 주의!</span></p><p data-ke-size="size18"><span>Q : 나는 List에 여러 Data타입이 들어있는데... 🥹</span></p><pre id="code_1668930701325" data-ke-language="swift" data-ke-type="codeblock"><code>NavigationLink("Mint", value: Color.mint) ➡️ Color 타입<br>NavigationLink("Black", value: "Black") ➡️ String 타입</code></pre><p data-ke-size="size18"><span>A : navigationDestination(for:destination:)를 여러개 쓰면 됨...</span></p><pre id="code_1668930746713" data-ke-language="swift" data-ke-type="codeblock"><code>List {<br> NavigationLink("Mint", value: Color.mint)<br> NavigationLink("Black", value: "Black")<br>}<br>.navigationDestination(for: Color.self) { color in<br> ColorDetailForColor(color: color) // Color 타입 용<br>}<br>.navigationDestination(for: String.self) { color in<br> ColorDetailForString(color: color) // String 타입 용<br>}</code></pre><p data-ke-size="size18"><span>&nbsp;이런식으로!!</span></p><p data-ke-size="size18"><span>기존 NavigationView를 사용했다면</span></p><pre id="code_1668932364025" data-ke-language="swift" data-ke-type="codeblock"><code>var body: some View {<br>  NavigationView { // This is deprecated.<br>   List {<br>    NavigationLink("Purple") {<br>     ColorDetail(color: .purple)<br>    }<br>    NavigationLink("Pink") {<br>     ColorDetail(color: .pink)<br>    }<br>    NavigationLink("Orange") {<br>     ColorDetail(color: .orange)<br>    }<br>   }<br>  }<br>  .navigationViewStyle(.stack)<br> }</code></pre><p data-ke-size="size18"><span>이런식으로 NavigationLink마다 Destination View를 지정했어야 했는데...훨씬 간결해지고 편해진 것 같아요?&nbsp;</span></p><p data-ke-size="size18"><span>물론 위 코드도 NavigationLink를 1개만 쓰도록 개선될 수 있겠지만.. 일단 그렇다~&nbsp;</span></p><h2 data-ke-size="size26"><b><span># Manage navigation state</span></b></h2><p data-ke-size="size18"><span>기본적으로 NavigationStack은 state를 관리하여 stack에 있는 view들을 추적하는데,</span></p><p data-ke-size="size18"><span>이걸 내가 직접 관리할수도 있습니다.&nbsp;</span></p><pre id="code_1668931397879" data-ke-language="swift" data-ke-type="codeblock"><code>@State private var presentedColor: [Color] = [] ✅<p>var body: some View {<br>    NavigationStack(path: $presentedColor) { ... } ✅<br>}</p></code></pre><p data-ke-size="size18"><span>이런식으로 State변수를 만들고, NavigationStack의 생성자 파라미터인 path에 넣어줍니다.</span></p><p data-ke-size="size18"><span><b><span>이제 NavigationStack은 우리가 만든 presentedColor State를 관찰하게 됩니다.</span></b></span></p><p data-ke-size="size18"><span>이제 presentedColor에 값들을 넣어봅시다.</span></p><pre id="code_1668931748314" data-ke-language="swift" data-ke-type="codeblock"><code>@State private var presentedColor: [Color] = [Color.brown, Color.cyan]</code></pre><p data-ke-size="size18"><span>이제 앱을 실행하면&nbsp;</span></p><figure data-ke-mobilestyle="widthOrigin" data-filename="Simulator Screen Recording - iPhone 14 Pro Max - 2022-11-20 at 17.10.00.gif" data-origin-width="296" data-origin-height="640"><span data-url="https://blog.kakaocdn.net/dn/Vg9OT/btrRBaEkdPK/KlIlP3dWSfo4Z0AP0z02gk/img.gif" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/Vg9OT/btrRBaEkdPK/KlIlP3dWSfo4Z0AP0z02gk/img.gif" srcset="https://blog.kakaocdn.net/dn/Vg9OT/btrRBaEkdPK/KlIlP3dWSfo4Z0AP0z02gk/img.gif" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-filename="Simulator Screen Recording - iPhone 14 Pro Max - 2022-11-20 at 17.10.00.gif" data-origin-width="296" data-origin-height="640"></span></figure><p data-ke-size="size18"><span>앱을 실행하자마자&nbsp;</span></p><pre id="code_1668931826135" data-ke-language="swift" data-ke-type="codeblock"><code>@State private var presentedColor: [Color] = [Color.brown, Color.cyan]</code></pre><p data-ke-size="size18"><span>root &gt; brown &gt; cyan 순으로 stack이 쌓인것을 확인 할 수 있습니다.</span></p><p data-ke-size="size18"><span>NavigationLink 를 사용하지 않고&nbsp;</span></p><pre id="code_1668931939234" data-ke-language="swift" data-ke-type="codeblock"><code>List {<br> NavigationLink("Mint", value: Color.mint)<br> NavigationLink("Pink", value: Color.pink)<br> NavigationLink("Teal", value: Color.teal)<br> Button("DeepLink", action: {<br>  self.showColors()<br> })<br>}<br>func showColors() {<br> self.presentedColor = [Color.gray, Color.green]<br>}</code></pre><p data-ke-size="size18"><span>이런식으로 제가 직접 값을 지정해주거나, 제거해주면 그대로 Navigation Stack이 수정됩니다.</span></p><p data-ke-size="size18"><span>Button을 클릭했을 때 presentedColor 값을 수정해주는 메소드를 호출하게 했습니다.&nbsp;</span></p><figure data-ke-mobilestyle="widthOrigin" data-filename="Simulator Screen Recording - iPhone 14 Pro Max - 2022-11-20 at 17.14.50.gif" data-origin-width="296" data-origin-height="640"><span data-url="https://blog.kakaocdn.net/dn/dEJ0BN/btrRFfkjvUl/ykzASS1laN0mxZkK5yisW0/img.gif" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/dEJ0BN/btrRFfkjvUl/ykzASS1laN0mxZkK5yisW0/img.gif" srcset="https://blog.kakaocdn.net/dn/dEJ0BN/btrRFfkjvUl/ykzASS1laN0mxZkK5yisW0/img.gif" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-filename="Simulator Screen Recording - iPhone 14 Pro Max - 2022-11-20 at 17.14.50.gif" data-origin-width="296" data-origin-height="640"></span></figure><p data-ke-size="size18"><span>보신 것 같이 NavigationStack의 path를 이용하면 <b>딥링크나 상태복원 등등을 쉽게 할 수 있게 됩니다.</b></span></p></div></div>"#
    }
}
